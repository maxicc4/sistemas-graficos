<!doctype html>
<html lang="es-AR">
    <meta charset="UTF-8"/>
    <head>
        <title></title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <canvas id="my-canvas">
            Your browser does not support the HTML5 canvas element.
        </canvas>

        <script type="text/javascript" src="vendor/js/gl-matrix.js"></script>
        <script type="text/javascript" src="vendor/js/jquery-3.5.1.js"></script>
        <script type="text/javascript" src="js/webgl.js"></script>
        <script type="text/javascript" src="js/grid3D.js"></script>
        <script type="text/javascript" src="js/commonSurfaces.js"></script>
        <script type="text/javascript" src="js/helicopterSurfaces.js"></script>
        <script type="text/javascript" src="js/object3d.js"></script>
        <script type="text/javascript" src="js/cameras.js"></script>
        <script type="text/javascript" src="js/cameraController.js"></script>
        <script type="text/javascript" src="js/helicopterController.js"></script>
        <script type="text/javascript" src="js/texture.js"></script>


        <script type="x-shader/x-vertex" id="vertex-shader">
            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aUV;

            uniform mat4 modelMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying vec2 vUV;

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo
                vUV=aUV;
            }
        </script>

        <script type="x-shader/x-vertex" id="vertex-shader-terrain">
            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec2 aUV;

            uniform mat4 modelMatrix;
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            uniform vec2 uOffsetUV;
            uniform float uScaleUV;

            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying vec2 vUV;

            uniform sampler2D uSampler0;

            const float epsilon=0.00000001;
            const float amplitud=40.0;

            void main(void) {
                vec3 position = aVertexPosition;
                vec2 uv = uOffsetUV + aUV*uScaleUV;

                vec4 center = texture2D(uSampler0, vec2(uv.s, uv.t));
                vec4 masU = texture2D(uSampler0, vec2(uv.s+epsilon, uv.t));
                vec4 masV = texture2D(uSampler0, vec2(uv.s, uv.t+epsilon));

                vec4 menosU = texture2D(uSampler0, vec2(uv.s-epsilon, uv.t));
                vec4 menosV = texture2D(uSampler0, vec2(uv.s, uv.t-epsilon));


                // elevamos la coordenada Y
                position.y+=center.x*amplitud;

                vec4 worldPos = modelMatrix*vec4(position, 1.0);

                gl_Position = projMatrix*viewMatrix*worldPos;

                vPosWorld=worldPos.xyz;

                /*
                 hay que calcular la normal ya que el valor original es la normal del plano
                 pero luego de elevar Y, el valor original no tiene sentido

                 La idea es calcular la diferencia de altura entre 2 muestras proximas
                 y estimar el vector tangente.

                 Haciendo lo mismo en el eje U y en el eje V tenemos 2 vectores tangentes a la superficie
                 Luego calculamos el producto vectorial y obtenemos la normal

                 Para tener un resultado con mayor precision, para cada eje U y V calculo 2 tangentes
                 y las promedio
                */
                float angU=atan((masU.x-center.x)*amplitud,epsilon);
                float angV=atan((masV.x-center.x)*amplitud,epsilon);

                // tangentes en U y en V
                vec3 gradU1=vec3(cos(angU),sin(angU),0.0);
                vec3 gradV1=vec3(0.0      ,sin(angV),cos(angV));

                angU=atan((center.x-menosU.x)*amplitud,epsilon);
                angV=atan((center.x-menosV.x)*amplitud,epsilon);

                // segundo conjunto de tangentes en U y en V
                vec3 gradU2=vec3(cos(angU),sin(angU),0.0);
                vec3 gradV2=vec3(0.0      ,sin(angV),cos(angV));



                // calculo el producto vectorial
                vec3 tan1=(gradV1+gradV2)/2.0;
                vec3 tan2=(gradU1+gradU2)/2.0;
                vNormal=cross(tan1,tan2);
                vUV=uv;
            }
        </script>

        <script type="x-shader/x-fragment" id="fragment-shader">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying vec2 vUV;

            uniform sampler2D uSampler0;

            uniform bool uUseLighting;          // usar iluminacion si/no

            void main(void) {
                vec3 lightVec=normalize(vec3(25.0,1000.0,1000.0)-vPosWorld);
                vec3 color=texture2D(uSampler0, vec2(vUV.s, vUV.t)).xyz;
                if (uUseLighting) {
                    color=dot(lightVec,vNormal)*color+vec3(0.2,0.2,0.2);
                }

                gl_FragColor = vec4(color,1.0);
            }
        </script>

        <script type="x-shader/x-fragment" id="fragment-shader-terrain">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying vec2 vUV;

            uniform sampler2D uSampler0;
            uniform sampler2D uSampler1;
            uniform sampler2D uSampler2;
            uniform sampler2D uSampler3;
            uniform sampler2D uSampler4;
            uniform sampler2D uSampler5;
            uniform sampler2D uSampler6;

            uniform bool uUseLighting;          // usar iluminacion si/no


            vec3 mod289(vec3 x)
            {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
                return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
                return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P)
            {
                vec3 Pi0 = floor(P); // Integer part for indexing
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            void main(void) {
                vec3 sand1=texture2D(uSampler1,vUV*100.0).xyz;
                vec3 sand2=texture2D(uSampler1,vUV*50.0).xyz;
                vec3 sand3=texture2D(uSampler1,vUV*2.11).xyz;
                vec3 color=mix(mix(sand1,sand2,0.5),sand3,0.3);

/*
                vec3 pasture1=texture2D(uSampler2,vUV*100.0).xyz;
                vec3 pasture2=texture2D(uSampler2,vUV*50.0).xyz;
                vec3 pasture3=texture2D(uSampler2,vUV*2.11).xyz;

                vec3 land1=texture2D(uSampler3,vUV*100.0).xyz;
                vec3 land2=texture2D(uSampler4,vUV*50.0).xyz;
                vec3 land3=texture2D(uSampler5,vUV*50.0).xyz;

                vec3 stone=texture2D(uSampler6,vUV*100.0).xyz;


                vec3 color1=mix(mix(pasture1,pasture2,0.5),pasture3,0.3);


                // genero una mascara 1 a partir de ruido perlin
                float noise1=cnoise(vUV.xyx*200.69);
                float noise2=cnoise(vUV.xyx*400.32);
                float noise3=cnoise(vUV.xyx*800.58);

                float mask1=mix(mix(noise1,noise2,0.5),noise3,0.3);
                mask1=smoothstep(-0.1,0.2,mask1);

                // combino tierra y roca usando la mascara 1
                vec3 color2=mix(mix(mix(land1,land2,0.5),land3,0.3),stone,mask1);
*/
                // genero la mascara 2 a partir del ruido perlin
                /*float noise4=cnoise(vUV.xyx*8.23);
                float noise5=cnoise(vUV.xyx*11.77);
                float noise6=cnoise(vUV.xyx*14.8);

                float mask2=mix(mix(noise4,noise5,0.5),noise6,0.3);
                mask2=smoothstep(-0.1,0.2,mask2);

                // combino color1 (tierra y rocas) con color2 a partir de la mascara2
                vec3 color=mix(color1,color2,mask2);
*/
                if (uUseLighting) {
                    vec3 lightVec=normalize(vec3(25.0,1000.0,1000.0)-vPosWorld);
                    color=dot(lightVec,vNormal)*color+vec3(0.2,0.2,0.2);
                }

                gl_FragColor = vec4(color,1.0);
            }
        </script>

        <script>
            $(document).ready(function(){
                initWebGL();
            });
        </script>


    </body>
</html>
